// Minimal Webflow-like animation runner for elements with data-w-id// Works in Astro or any static export without Webflow's runtime.(function () {  const EASING = 'cubic-bezier(.2,.6,.2,1)';  // 1) Optional per-element overrides by Webflow ID  //    Find IDs in your markup: el.getAttribute('data-w-id')  //    type: 'fade-up' | 'fade-in' | 'slide-left' | 'slide-right' | 'zoom-in' | 'counter'  const CONFIG = {    // 'eaee1984-fe14-7288-1173-d39b43d97081': { type: 'fade-up', distance: 16, duration: 600, delay: 0 },    // 'dbdd18d1-d28e-77ac-b1d8-706e81bf030c': { type: 'fade-in', duration: 500 },    // 'f1ca036c-72ef-374c-f66c-2f81e977f5e5': { type: 'fade-up', delay: 150 },    // '11eddd24-ae6d-01d9-787d-20035795758c': { type: 'slide-left', distance: 40, duration: 1600 }, // e.g., your brand strip  };  // 2) Defaults if an element isn't listed in CONFIG  function inferConfig(el) {    // If Webflow left "opacity:0" inline, assume it was meant to fade in    const style = getComputedStyle(el);    if (style.opacity === '0' || el.getAttribute('style')?.includes('opacity: 0')) {      // common hero/section content pattern      if (el.classList.contains('heading-two') || el.classList.contains('heading-three')) {        return { type: 'fade-up', distance: 12, duration: 550 };      }      return { type: 'fade-in', duration: 500 };    }    // Known patterns (tweak as you like)    if (el.classList.contains('contact-info-item')) return { type: 'fade-up', distance: 12, duration: 500 };    if (el.classList.contains('hero-left'))        return { type: 'fade-up', distance: 16, duration: 600 };    if (el.classList.contains('hero-right'))       return { type: 'fade-up', distance: 16, duration: 700, delay: 75 };    if (el.classList.contains('counter'))          return { type: 'counter' };    // Fallback    return { type: 'fade-up', distance: 12, duration: 500 };  }  function runAnimation(el, conf) {    const c = conf || inferConfig(el);    // Normalize    const duration = c.duration ?? 600;    const delay    = c.delay ?? 0;    const distance = c.distance ?? 16;    const finish = () => {      el.style.opacity = '1';      el.style.transform = 'none';      el.style.willChange = 'auto';    };    el.style.willChange = 'opacity, transform';    switch (c.type) {      case 'fade-in':        el.animate(          [{ opacity: 0 }, { opacity: 1 }],          { duration, delay, easing: EASING, fill: 'both' }        ).onfinish = finish;        break;      case 'fade-up':        el.animate(          [            { opacity: 0, transform: `translateY(${distance}px)` },            { opacity: 1, transform: 'translateY(0)' }          ],          { duration, delay, easing: EASING, fill: 'both' }        ).onfinish = finish;        break;      case 'slide-left':        el.animate(          [            { opacity: 0, transform: `translateX(${distance}px)` },            { opacity: 1, transform: 'translateX(0)' }          ],          { duration, delay, easing: EASING, fill: 'both' }        ).onfinish = finish;        break;      case 'slide-right':        el.animate(          [            { opacity: 0, transform: `translateX(-${distance}px)` },            { opacity: 1, transform: 'translateX(0)' }          ],          { duration, delay, easing: EASING, fill: 'both' }        ).onfinish = finish;        break;      case 'zoom-in':        el.animate(          [            { opacity: 0, transform: 'scale(.96)' },            { opacity: 1, transform: 'scale(1)' }          ],          { duration, delay, easing: EASING, fill: 'both' }        ).onfinish = finish;        break;      case 'counter':        animateCounter(el, { duration: c.duration ?? 1200, delay });        break;      default:        // fallback        el.animate(          [            { opacity: 0, transform: `translateY(${distance}px)` },            { opacity: 1, transform: 'translateY(0)' }          ],          { duration, delay, easing: EASING, fill: 'both' }        ).onfinish = finish;    }  }  // Simple counter: add data-count-to on the wrapper OR on any .counter-number  // Example: <div class="counter" data-count-to="650"></div>  // Or set per element: <div class="counter-number" data-count-to="650">0</div>  function animateCounter(wrapper, { duration = 1200, delay = 0 } = {}) {    const targets = wrapper.querySelectorAll('[data-count-to]');    const elements = targets.length ? targets : wrapper.querySelectorAll('.counter-number');    elements.forEach((el) => {      const end = parseInt(el.getAttribute('data-count-to') || el.textContent.replace(/\D+/g, ''), 10);      const start = 0;      const startTime = performance.now() + delay;      function tick(now) {        const t = Math.min(1, (now - startTime) / duration);        if (t < 0) { requestAnimationFrame(tick); return; }        const eased = t * (2 - t); // easeOutQuad        const val = Math.round(start + (end - start) * eased);        el.textContent = val.toLocaleString();        if (t < 1) requestAnimationFrame(tick);      }      requestAnimationFrame(tick);    });  }  // IntersectionObserver to trigger once when visible  function setup() {    // Make sure hidden elements become visible even if JS animations don't run    const safety = document.createElement('style');    safety.innerHTML = `      /* reveal anything Webflow left at opacity:0 */      [data-w-id][style*="opacity: 0"] { opacity: 1 !important; transform: none !important; }    `;    document.head.appendChild(safety);    const io = new IntersectionObserver(      (entries) => {        entries.forEach((entry) => {          if (!entry.isIntersecting) return;          const el = entry.target;          io.unobserve(el);          const id = el.getAttribute('data-w-id');          const conf = CONFIG[id];          runAnimation(el, conf);        });      },      { threshold: 0.2 }    );    document.querySelectorAll('[data-w-id]').forEach((el) => {      // If you want immediate animations (no scroll trigger), call runAnimation(el) directly      io.observe(el);    });  }  if (document.readyState === 'loading') {    document.addEventListener('DOMContentLoaded', setup);  } else {    setup();  }})();